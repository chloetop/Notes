Important homework 

Homework 4 Q2. 

Homework 4 Q5. The rules of mod% for positive numbers cannot be used for negative numbers directively. 

The knowledge need to be reviewed. 

Big omega notation. 

Homework 5 Q2

be aware of the height and depth of tree. 

Homework 5 Q4

Note that the question is that the descendants diff is no more than 5, not the height...

Homework 5 Q5

Do not forget to reset the visit flag of nodes. 

Homework 6 
Q1 the height of avl-tree < 2log(n) + 2, the height of splay tree is h < log(n+1)

external node is the nodes which do not store anything. 

Q6 removeExternal is to remove the external node and its parent, replace its parent by its sibling. 

So if removeExternal is called during the remove, if the deleted node's parent is root. In that case, the other child of the root would become 
the root afterwards, so it is still an AVL tree. 
Else if the parent is not root, the only AVL-tree which would become non-AVL tree is the one rooted at w (which is the parent of the parent of v)

Homework 7 

Q2 just use the recursive algorithm to scan each node

Q5 note that the first transformation of the sum equation and when n> 3, the equation i<2^(i/2) holds.  

Homework 8

Q1 do not forget to remove the duplicates. 

Q2 Using bucket sorting. 

Q3 Find the inverses in a sequence. 

use recursive method to solve this. firstly, divide the sequence into 2 parts. find the inverses in both of the parts. then find the 
inversions that happen among the two. 

note that once a merge is called, the two sub-sequences are already sorted. 

Homework 9 

Q1 The difference between map and dictionary ADT is that map does not hold elements with the same key while dic does. 

So we just add one more dimension to make the keys in map to be unique. 

Q2 Note that we can only move forward the elements whose keys are equal to the hash(k). Once we encounter with a key whose
key is differ from the hash(key), that means that key is not generated by probing but direct hashing. 

Q3 and Q4 Note that the time complexity should consider the length of the successors. 

Homework 10 

Q1. Instead of just returning the matching, we set i = i + 1, and j = f(m-1);

Q2. Generate a new text T' = T[n-m, ..., n-1] + T[0 ... m]. Run KMP algorithm on T' and P'.

Q5. a partial string is actually not a part of the string. Consequently, during the deletion, it cannot be deleted. 

Algorithm(T, s)
Input: T and string s
Output: a T without s
{
    search for s in the T
    if(s was not found){
       print 's is not found';      
       return -1;   //delete failed
    }
    
    else
    {
    	let u be the node where s is just found;
    	if(s is not equal to the whole string encoded at u or u has a child)
    	{
    		print 's is just a partial string';
    		return -1;   //delete failed. 
    	}
    	
    	v = the parent of u;
    	delete u;
    	if(v has only one child c)
    	{
    		v.string = v.string + c.string;
    	}
    	
    	return 0;   
    
	}
}

so sometimes if my own design of algorithm is very trivial, try if we can describe the algorithm in some high-level way. 

Q6. use LCS to solve this. 

